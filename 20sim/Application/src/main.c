/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  xxmain.c
 *  subm:  PositionControllerPan
 *  model: Jiwy
 *  expmt: Jiwy
 *  date:  June 7, 2018
 *  time:  2:05:31 PM
 *  user:  Universiteit Twente
 *  from:  20-sim 4.7 Campus License
 *  build: 4.7.0.8692
 **********************************************************/

/* This file is a demo application of how the submodel function can 
 * be used. It uses the global time variables that are used by both
 * the submodel and the integration method.
 *
 * PLEASE NOTE: THIS IS AN EXAMPLE WHERE ALL INPUTS ARE ZERO ! 
 * USE YOUR OWN INPUTS INSTEAD!! ALSO THE SUBMODEL MIGHT SIMPLY 
 * NOT WORK CORRECTLY WITH INPUTS THAT ARE ZERO.
 */

/* 20-sim include files */
#include "xxsubmodpan.h"
#include "xxsubmodtilt.h"
#include "stdio.h"
#include "gpmc_driver_c.h"
#include <math.h>
#include <fcntl.h>      // open()
#include <unistd.h>     // close()
#include <stdint.h>
#include <stdlib.h>
#include <time.h>


/* The pan encoder spans 2000 values which correspond to approximately Pi radians. */
double ConvertRad(int32_t val)
{
	return ((double)val/2000.0) * M_PI;
}

/* According to 20SIM, the output is a signal between -20 and 20. 
This output must be converted to a PWM output between 0 and 250 
and a direction according to a truthtable. */
uint32_t ConvertPWM(double val)
{
	//Brake
	if(val == 0)
		return 0;
	
	uint32_t ret_val = 0;
	double ch = abs(val * 250.0);
	//printf("%f, %f\n", val, ch);
	ret_val = (uint32_t) (ch);
	//Clockwise
	if(val > 0)
	{
		//INA = 1;
		//INB = 0;
		ret_val |= 0x01 << 8;
	}
	//Counterclockwise
	else
	{
		//INA = 0;
		//INB = 1;
		ret_val |= 0x02 << 8;
	}
	return ret_val;
}

uint32_t CheckOutput(uint32_t val)
{
	return val;
}



void move2end(int fd){ 
	reset();
	printf("moving to end\n");
	int32_t pan, tilt;
	int32_t lp = 3000, lt = 3000; // defined out of range of encoders
	bool pend = FALSE, tend = FALSE;
	setGPMCValue(fd, ConvertPwm(-0.5), 4);
	setGPMCValue(fd, ConvertPwm(-0.5), 6);

	while(!(pend && tend)){ // terminate when both have gone to the end
		usleep(2000);
		pan = getGPMCValue(fd, 0);
		tilt = getGPMCValue(fd, 2);
		if (pan == lp) {
			setGPMCValue(fd, 0, 4);
			pend = TRUE;
		}
		if (tilt == lt) {
			setGPMCValue(fd, 0, 6);
			tend = TRUE;
		}
		lp = pan;
		lt = tilt;
	}
	reset();
}



void reset(int fd) {
    setGPMCValue(fd, 1, 7);
}

/* The main function */
int main(int argc, char* argv[])
{
	uint32_t Mpan = 0, Mtilt = 0;
	XXDouble upan [2 + 1];
	XXDouble ypan [2 + 1];
	XXDouble utilt [3 + 1];
	XXDouble ytilt [1 + 1];

	// if (2 != argc)
	// {
	// printf("Usage: %s <device_name>\n", argv[0]);
	// return 1;
	// }
	int fd;
	// open connection to device.
	printf("Opening gpmc_fpga...\n");
	fd = open("/dev/gpmc_fpga", 0);
	if (0 > fd)
	{
	printf("Error, could not open device: %s.\n", argv[1]);
	return 1;
	}
	

	/* Initialize the inputs and outputs with correct initial values */
	upan[0] = 0.0;		/* in */
	upan[1] = 0.0;		/* position */

	ypan[0] = 0.0;		/* corr */
	ypan[1] = 0.0;		/* out */





/* Initialize the inputs and outputs with correct initial values */
	utilt[0] = 0.0;		/* corr */
	utilt[1] = 0.15;		/* in */
	utilt[2] = 0.0;		/* position */

	ytilt[0] = 0.0;		/* out */


	/*int a, b;
	while(1){
		a = getGPMCValue(fd, 0);
		b = getGPMCValue(fd, 2);
		setGPMCValue(fd,0,6);
		//printf("Radians: %f %f\n", ConvertRad(a), ConvertRad(b)); 
		printf("RAW: %7d %7d\r", a,b); 
		usleep(1000);
		if(b >100 || b < -100) {
		  setGPMCValue(fd, 1, 7);
		}
	}*/
/*
	Mpan = ConvertPWM(10);
	Mtilt = ConvertPWM(10);
	setGPMCValue(fd, Mpan, 4);		
	setGPMCValue(fd, Mtilt, 6);
	usleep(1000000);
	setGPMCValue(fd, 0, 4);		
	setGPMCValue(fd, 0, 6);*/
	//return 0;
	reset(fd);
	move2end(fd);

	
	clock_t lastclk = clock()
	clock_t clockdiff;
	clock_t clk;
	
	
	/* Initialize the submodel itself */
	XXInitializeSubmodelpan (upan, ypan, (double)clock()/CLOCKS_PER_SEC);
	/* Initialize the submodel itself */
	XXInitializeSubmodeltilt (utilt, ytilt, (double)clock()/CLOCKS_PER_SEC);

	while (1)
	{
		clk = clock();
		// clockdiff = clk - lastclk;
		// if (clockdiff >= (clock_t)((double)CLOCKS_PER_SEC*0.01)){
		//Get and convert the decoder readings. 
		upan[1] = ConvertRad(getGPMCValue(fd, 2)); 		
		utilt[2] = ConvertRad(getGPMCValue(fd, 0)); 

		/* Call the submodel to calculate the output */
		XXCalculateSubmodelpan (upan, ypan, (double)clk/CLOCKS_PER_SEC);
		XXCalculateSubmodeltilt (utilt, ytilt, (double)clk/CLOCKS_PER_SEC);

		//Convert, check and send the Motor steering values
		Mpan = CheckOutput(ConvertPWM(ypan[1]));
		Mtilt = CheckOutput(ConvertPWM(ytilt[0]));
		setGPMCValue(fd, Mpan, 4);		
		setGPMCValue(fd, Mtilt, 6);
		//printf("err: %7f, %7f\r", utilt[1] - utilt[2], ytilt[0]);
		//printf("Timestep: %f, %f, %f, %f, %f, %d, %d\n", xx_timepan, upan[1], utilt[2], ypan[1], ytilt[0], Mpan,Mtilt);
		//usleep(1000);
	
		// lastclk = clk;
	}

	/* Perform the final calculations */
	XXTerminateSubmodelpan (upan, ypan, xx_timepan);
	XXTerminateSubmodeltilt (utilt, ytilt, xx_timetilt);
	close(fd);

	return 0;
}

