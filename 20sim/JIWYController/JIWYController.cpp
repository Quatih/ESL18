/**********************************************************
 * This file is generated by the 20-sim C++ Code Generator
 *
 *  file:  JIWYController.cpp
 *  subm:  JIWYController
 *  model: JIWY-better-tuned
 *  expmt: JIWY-better-tuned
 *  date:  June 19, 2018
 *  time:  2:04:53 PM
 *  user:  Universiteit Twente
 *  from:  20-sim 4.7 Campus License
 *  build: 4.7.0.8692
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
/* Include the header for memcpy and memset
 * You may need to change this into <memory.h> for older compilers
 */
#include <string.h>

/* 20-sim include files */
#include "JIWYController.h"

/* Delta margin used for end time checking */
const XXDouble c_delta = 1.0e-7;

/* this PRIVATE function sets the input variables from the input vector */
void JIWYController::CopyInputsToVariables (XXDouble *u)
{
	/* copy the input vector to the input variables */
	m_V[14] = u[0];		/* Enc_Pan */
	m_V[16] = u[1];		/* Enc_Tilt */

}

/* this PRIVATE function uses the output variables to fill the output vector */
void JIWYController::CopyVariablesToOutputs (XXDouble *y)
{
	/* copy the output variables to the output vector */
	y[0] = 	m_V[15];		/* Motor_Pan */
	y[1] = 	m_V[17];		/* Motor_Tilt */

}

JIWYController::JIWYController(void)
{
	m_number_constants = 0;
	m_number_parameters = 20;
	m_number_initialvalues = 10;
	m_number_variables = 18;
	m_number_states = 10;
	m_number_rates = 10;
	m_number_matrices = 0;
	m_number_unnamed = 0;

	/* the variable arrays */
	m_C = new XXDouble[0 + 1];		/* constants */
	m_P = new XXDouble[20 + 1];		/* parameters */
	m_I = new XXDouble[10 + 1];		/* initial values */
	m_V = new XXDouble[18 + 1];		/* variables */
	m_s = new XXDouble[10 + 1];		/* states */
	m_R = new XXDouble[10 + 1];		/* rates (or new states) */
	m_M = new XXMatrix[0 + 1];		/* matrices */
	m_U = new XXDouble[0 + 1];		/* unnamed */
	m_workarray = new XXDouble[0 + 1];

	Reset(0.0);
	m_finish_time = 20.0;
}

void JIWYController::Reset(XXDouble starttime)
{
	m_start_time = starttime;
	m_step_size = 0.005;
	m_time = starttime;
	m_major = true;
	m_stop_run = false;

	/* Clear the allocated variable memory */
	memset(m_C, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_P, 0, (20 + 1) * sizeof(XXDouble));
	memset(m_I, 0, (10 + 1) * sizeof(XXDouble));
	memset(m_V, 0, (18 + 1) * sizeof(XXDouble));
	memset(m_s, 0, (10 + 1) * sizeof(XXDouble));
	memset(m_R, 0, (10 + 1) * sizeof(XXDouble));
	memset(m_M, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_U, 0, (0 + 1) * sizeof(XXDouble));
	memset(m_workarray, 0, (0 + 1) * sizeof(XXDouble));


	state = initialrun;
}

bool JIWYController::IsFinished(void)
{
	return (state == finished);
}

JIWYController::~JIWYController(void)
{
	/* free memory */
	delete[] m_C;
	delete[] m_P;
	delete[] m_I;
	delete[] m_V;
	delete[] m_s;
	delete[] m_R;
	delete[] m_M;
	delete[] m_U;
	delete[] m_workarray;
}

/* the initialization function for submodel */
void JIWYController::Initialize (XXDouble *u, XXDouble *y, XXDouble t)
{
	/* initialization phase (allocating memory) */
	m_initialize = true;
	m_stop_run = false;

	/* set the constants */


	/* set the parameters */
	m_P[0] = 1.0;		/* ControllerPan\ControllerPan\PID_Pan\kp {} */
	m_P[1] = 10.0;		/* ControllerPan\ControllerPan\PID_Pan\tauD {s} */
	m_P[2] = 0.1;		/* ControllerPan\ControllerPan\PID_Pan\beta {} */
	m_P[3] = 3.0;		/* ControllerPan\ControllerPan\PID_Pan\tauI {s} */
	m_P[4] = 0.003141592;		/* ControllerPan\MA_Pan\Conversion\K */
	m_P[5] = 1.0;		/* ControllerPan\MA_Pan\Limit\maximum */
	m_P[6] = -1.0;		/* ControllerPan\MA_Pan\Limit\minimum */
	m_P[7] = 0.2;		/* ControllerTilt\ControllerTilt\PID_Tilt\kp {} */
	m_P[8] = 1.0;		/* ControllerTilt\ControllerTilt\PID_Tilt\tauD {s} */
	m_P[9] = 0.1;		/* ControllerTilt\ControllerTilt\PID_Tilt\beta {} */
	m_P[10] = 10.0;		/* ControllerTilt\ControllerTilt\PID_Tilt\tauI {s} */
	m_P[11] = 0.003141592;		/* ControllerTilt\MA_Tilt\Conversion\K */
	m_P[12] = 1.0;		/* ControllerTilt\MA_Tilt\Limit\maximum */
	m_P[13] = -1.0;		/* ControllerTilt\MA_Tilt\Limit\minimum */
	m_P[14] = 1.0;		/* JoyStick\PulsePan\start_time {s} */
	m_P[15] = 6.0;		/* JoyStick\PulsePan\stop_time {s} */
	m_P[16] = 1.0;		/* JoyStick\PulsePan\amplitude {} */
	m_P[17] = 3.0;		/* JoyStick\PulseTilt\start_time {s} */
	m_P[18] = 8.0;		/* JoyStick\PulseTilt\stop_time {s} */
	m_P[19] = -1.0;		/* JoyStick\PulseTilt\amplitude {} */


	/* set the initial values */
	m_I[0] = 0.0;		/* ControllerPan\ControllerPan\PID_Pan\uD_previous_initial */
	m_I[1] = 0.0;		/* ControllerPan\ControllerPan\PID_Pan\error_previous_initial */
	m_I[2] = 0.0;		/* ControllerPan\ControllerPan\PID_Pan\uI_previous_initial */
	m_I[3] = 0.0;		/* ControllerTilt\ControllerTilt\PID_Tilt\uD_previous_initial */
	m_I[4] = 0.0;		/* ControllerTilt\ControllerTilt\PID_Tilt\error_previous_initial */
	m_I[5] = 0.0;		/* ControllerTilt\ControllerTilt\PID_Tilt\uI_previous_initial */
	m_I[6] = 0.0;		/* u_1_initial */
	m_I[7] = 0.0;		/* u_2_initial */
	m_I[8] = 0.0;		/* u_3_initial */
	m_I[9] = 0.0;		/* u_4_initial */


	/* set the states */
	m_s[0] = m_I[0];		/* ControllerPan\ControllerPan\PID_Pan\uD_previous */
	m_s[1] = m_I[1];		/* ControllerPan\ControllerPan\PID_Pan\error_previous */
	m_s[2] = m_I[2];		/* ControllerPan\ControllerPan\PID_Pan\uI_previous */
	m_s[3] = m_I[3];		/* ControllerTilt\ControllerTilt\PID_Tilt\uD_previous */
	m_s[4] = m_I[4];		/* ControllerTilt\ControllerTilt\PID_Tilt\error_previous */
	m_s[5] = m_I[5];		/* ControllerTilt\ControllerTilt\PID_Tilt\uI_previous */
	m_s[6] = m_I[6];		/* u_1 */
	m_s[7] = m_I[7];		/* u_2 */
	m_s[8] = m_I[8];		/* u_3 */
	m_s[9] = m_I[9];		/* u_4 */


	/* set the matrices */


	/* (re-)initialize the integration method */
	myintegmethod.Initialize(this);
	
	/* copy the inputs */
	m_time = t;
	CopyInputsToVariables (u);

	/* calculate initial and static equations */
	CalculateInitial ();
	CalculateStatic ();
	CalculateInput ();
	CalculateDynamic ();
	CalculateOutput ();

	/* Set the outputs */
	CopyVariablesToOutputs (y);

	/* end of initialization phase */
	m_initialize = false;

	state = mainrun;
}

/* the function that calculates the submodel */
void JIWYController::Calculate (XXDouble *u, XXDouble *y /*, XXDouble t*/)
{
	switch (state)
	{
		case initialrun:	/* calculate the model for the first time */
			Initialize(u, y, 0.0);
			break;
		case mainrun:	/* calculate the model */
			if ( ( m_time <= (m_finish_time - m_step_size  + c_delta )) || ( m_finish_time == 0.0 ) )
			{
				/* another precessor submodel could determine the parameters of this submodel
				   and therefore the static parameter calculations need to be performed. */
				CalculateStatic ();
				CopyInputsToVariables (u);
				CalculateInput ();
				myintegmethod.Step();
				CalculateOutput ();
				CopyVariablesToOutputs (y);
			}
			else
			{
				state = finished;
			}

			if ( ( m_stop_run == true ) || (( m_finish_time != 0.0 ) && ( m_time + c_delta >= m_finish_time)) )
			{
				state = finished;
			}
			break;
		case finished:
			break;
		default:
			break;
	}
}

/* the termination function for submodel */
void JIWYController::Terminate (XXDouble *u, XXDouble *y /*, XXDouble t */)
{
	/* copy the inputs */
	CopyInputsToVariables (u);

	/* calculate the final model equations */
	CalculateFinal ();

	/* set the outputs */
	CopyVariablesToOutputs (y);
}


/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void JIWYController::CalculateInitial (void)
{

}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void JIWYController::CalculateStatic (void)
{

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void JIWYController::CalculateInput (void)
{

}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void JIWYController::CalculateDynamic (void)
{
	/* ControllerPan\ControllerPan\PID_Pan\factor = 1 / (sampletime + ControllerPan\ControllerPan\PID_Pan\tauD * ControllerPan\ControllerPan\PID_Pan\beta); */
	m_V[1] = 1.0 / (m_step_size + m_P[1] * m_P[2]);

	/* ControllerTilt\ControllerTilt\PID_Tilt\factor = 1 / (sampletime + ControllerTilt\ControllerTilt\PID_Tilt\tauD * ControllerTilt\ControllerTilt\PID_Tilt\beta); */
	m_V[6] = 1.0 / (m_step_size + m_P[8] * m_P[9]);

	/* u_1_next = dtime; */
	m_R[6] = m_time;

	/* u_2_next = dtime; */
	m_R[7] = m_time;

	/* JoyStick\PulsePan\change = (u_1 < JoyStick\PulsePan\start_time and dtime >= JoyStick\PulsePan\start_time) or (u_2 < JoyStick\PulsePan\stop_time and dtime >= JoyStick\PulsePan\stop_time); */
	m_V[11] = (m_s[6] < m_P[14] && m_time >= m_P[14]) || (m_s[7] < m_P[15] && m_time >= m_P[15]);

	/* JoyStick\PulsePan\output = JoyStick\PulsePan\amplitude * (step (JoyStick\PulsePan\start_time) - step (JoyStick\PulsePan\stop_time)); */
	m_V[10] = m_P[16] * (XXStep (m_P[14], m_time) - XXStep (m_P[15], m_time));

	/* u_3_next = dtime; */
	m_R[8] = m_time;

	/* u_4_next = dtime; */
	m_R[9] = m_time;

	/* JoyStick\PulseTilt\change = (u_3 < JoyStick\PulseTilt\start_time and dtime >= JoyStick\PulseTilt\start_time) or (u_4 < JoyStick\PulseTilt\stop_time and dtime >= JoyStick\PulseTilt\stop_time); */
	m_V[13] = (m_s[8] < m_P[17] && m_time >= m_P[17]) || (m_s[9] < m_P[18] && m_time >= m_P[18]);

	/* JoyStick\PulseTilt\output = JoyStick\PulseTilt\amplitude * (step (JoyStick\PulseTilt\start_time) - step (JoyStick\PulseTilt\stop_time)); */
	m_V[12] = m_P[19] * (XXStep (m_P[17], m_time) - XXStep (m_P[18], m_time));

	/* ControllerPan\measIO = Enc_Pan; */
	m_V[4] = m_V[14];

	/* ControllerTilt\measIO = Enc_Tilt; */
	m_V[9] = m_V[16];

	/* ControllerPan\MA_Pan\Conversion\output = ControllerPan\MA_Pan\Conversion\K * ControllerPan\measIO; */
	m_V[2] = m_P[4] * m_V[4];

	/* ControllerTilt\MA_Tilt\Conversion\output = ControllerTilt\MA_Tilt\Conversion\K * ControllerTilt\measIO; */
	m_V[7] = m_P[11] * m_V[9];

	/* ControllerPan\ControllerPan\PID_Pan\error = JoyStick\PulsePan\output - ControllerPan\MA_Pan\Conversion\output; */
	m_R[1] = m_V[10] - m_V[2];

	/* ControllerTilt\ControllerTilt\PID_Tilt\error = JoyStick\PulseTilt\output - ControllerTilt\MA_Tilt\Conversion\output; */
	m_R[4] = m_V[12] - m_V[7];

	/* ControllerPan\ControllerPan\PID_Pan\uD = ControllerPan\ControllerPan\PID_Pan\factor * (((ControllerPan\ControllerPan\PID_Pan\tauD * ControllerPan\ControllerPan\PID_Pan\uD_previous) * ControllerPan\ControllerPan\PID_Pan\beta + (ControllerPan\ControllerPan\PID_Pan\tauD * ControllerPan\ControllerPan\PID_Pan\kp) * (ControllerPan\ControllerPan\PID_Pan\error - ControllerPan\ControllerPan\PID_Pan\error_previous)) + (sampletime * ControllerPan\ControllerPan\PID_Pan\kp) * ControllerPan\ControllerPan\PID_Pan\error); */
	m_R[0] = m_V[1] * (((m_P[1] * m_s[0]) * m_P[2] + (m_P[1] * m_P[0]) * (m_R[1] - m_s[1])) + (m_step_size * m_P[0]) * m_R[1]);

	/* ControllerPan\ControllerPan\PID_Pan\uI = ControllerPan\ControllerPan\PID_Pan\uI_previous + (sampletime * ControllerPan\ControllerPan\PID_Pan\uD) / ControllerPan\ControllerPan\PID_Pan\tauI; */
	m_R[2] = m_s[2] + (m_step_size * m_R[0]) / m_P[3];

	/* ControllerPan\ControllerPan\PID_Pan\output = ControllerPan\ControllerPan\PID_Pan\uI + ControllerPan\ControllerPan\PID_Pan\uD; */
	m_V[0] = m_R[2] + m_R[0];

	/* ControllerTilt\ControllerTilt\PID_Tilt\uD = ControllerTilt\ControllerTilt\PID_Tilt\factor * (((ControllerTilt\ControllerTilt\PID_Tilt\tauD * ControllerTilt\ControllerTilt\PID_Tilt\uD_previous) * ControllerTilt\ControllerTilt\PID_Tilt\beta + (ControllerTilt\ControllerTilt\PID_Tilt\tauD * ControllerTilt\ControllerTilt\PID_Tilt\kp) * (ControllerTilt\ControllerTilt\PID_Tilt\error - ControllerTilt\ControllerTilt\PID_Tilt\error_previous)) + (sampletime * ControllerTilt\ControllerTilt\PID_Tilt\kp) * ControllerTilt\ControllerTilt\PID_Tilt\error); */
	m_R[3] = m_V[6] * (((m_P[8] * m_s[3]) * m_P[9] + (m_P[8] * m_P[7]) * (m_R[4] - m_s[4])) + (m_step_size * m_P[7]) * m_R[4]);

	/* ControllerTilt\ControllerTilt\PID_Tilt\uI = ControllerTilt\ControllerTilt\PID_Tilt\uI_previous + (sampletime * ControllerTilt\ControllerTilt\PID_Tilt\uD) / ControllerTilt\ControllerTilt\PID_Tilt\tauI; */
	m_R[5] = m_s[5] + (m_step_size * m_R[3]) / m_P[10];

	/* ControllerTilt\ControllerTilt\PID_Tilt\output = ControllerTilt\ControllerTilt\PID_Tilt\uI + ControllerTilt\ControllerTilt\PID_Tilt\uD; */
	m_V[5] = m_R[5] + m_R[3];

	/* ControllerPan\MA_Pan\Limit\output = (if ControllerPan\ControllerPan\PID_Pan\output < ControllerPan\MA_Pan\Limit\minimum then ControllerPan\MA_Pan\Limit\minimum else (if ControllerPan\ControllerPan\PID_Pan\output > ControllerPan\MA_Pan\Limit\maximum then ControllerPan\MA_Pan\Limit\maximum else ControllerPan\ControllerPan\PID_Pan\output end) end); */
	m_V[3] = ((m_V[0] < m_P[6]) ? 
		/* ControllerPan\MA_Pan\Limit\minimum */
		m_P[6]
	:
		/* (if ControllerPan\ControllerPan\PID_Pan\output > ControllerPan\MA_Pan\Limit\maximum then ControllerPan\MA_Pan\Limit\maximum else ControllerPan\ControllerPan\PID_Pan\output end) */
		((m_V[0] > m_P[5]) ? 
			/* ControllerPan\MA_Pan\Limit\maximum */
			m_P[5]
		:
			/* ControllerPan\ControllerPan\PID_Pan\output */
			m_V[0]
		)
	);

	/* ControllerTilt\MA_Tilt\Limit\output = (if ControllerTilt\ControllerTilt\PID_Tilt\output < ControllerTilt\MA_Tilt\Limit\minimum then ControllerTilt\MA_Tilt\Limit\minimum else (if ControllerTilt\ControllerTilt\PID_Tilt\output > ControllerTilt\MA_Tilt\Limit\maximum then ControllerTilt\MA_Tilt\Limit\maximum else ControllerTilt\ControllerTilt\PID_Tilt\output end) end); */
	m_V[8] = ((m_V[5] < m_P[13]) ? 
		/* ControllerTilt\MA_Tilt\Limit\minimum */
		m_P[13]
	:
		/* (if ControllerTilt\ControllerTilt\PID_Tilt\output > ControllerTilt\MA_Tilt\Limit\maximum then ControllerTilt\MA_Tilt\Limit\maximum else ControllerTilt\ControllerTilt\PID_Tilt\output end) */
		((m_V[5] > m_P[12]) ? 
			/* ControllerTilt\MA_Tilt\Limit\maximum */
			m_P[12]
		:
			/* ControllerTilt\ControllerTilt\PID_Tilt\output */
			m_V[5]
		)
	);

}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void JIWYController::CalculateOutput (void)
{
	/* Motor_Pan = ControllerPan\MA_Pan\Limit\output; */
	m_V[15] = m_V[3];

	/* Motor_Tilt = ControllerTilt\MA_Tilt\Limit\output; */
	m_V[17] = m_V[8];

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void JIWYController::CalculateFinal (void)
{

}



bool JIWYController::SetFinishTime(XXDouble newtime)
{
	if ((newtime <= 0.0) || ( newtime > m_time))
	{
		m_finish_time = newtime;
		return true;
	}

	return false;
}

